!----------------------------------------------------------------------
! PARAMESH - an adaptive mesh library.
! Copyright (C) 2003
!
! Use of the PARAMESH software is governed by the terms of the
! usage agreement which can be found in the file
! 'PARAMESH_USERS_AGREEMENT' in the main paramesh directory.
!----------------------------------------------------------------------

       subroutine amr_timestep(dt,dtmin,dtmax,mype)




!-----------------------------------------------------------------------
! This routine computes the hydro timestep, and distributes
! it to all the processors.
!
!
! This template shows an example of how pointers may be used in PARAMESH.
!
!
! Written:      Peter MacNeice February 1997
!
!
      use paramesh_dimensions
      use physicaldata
      use tree

#include "amr_shmem.fh"
      include 'shmem_reduce.fh'

      real, parameter :: courant = .4

!------------------------------------------

! local variables

      real :: speed2(il_bnd:iu_bnd,jl_bnd:ju_bnd,kl_bnd:ku_bnd)
      real :: press(il_bnd:iu_bnd,jl_bnd:ju_bnd,kl_bnd:ku_bnd)
      real :: maxspeed

      real :: dtl,dtmaxl,dtl0
      save :: dtl,tpwrk,dtmaxl,dtl0

      integer :: npes
      integer, external :: shmem_n_pes

      include 'pointers.fh'

      integer large_integer,intgr
      parameter(large_integer=huge(intgr)/100)

!-----------------------------------------------------------------------


      call shmem_barrier_all()

      npes = shmem_n_pes()

      dtmax = 0.
      dtmin = 1.e30
      dtl = 1.e30
      dtlevel(:) = 1.e30

!------------------------------------------


! loop over leaf blocks on this processor
      if(lnblocks.gt.0) then
      do l=1,lnblocks

#ifndef ADVANCE_ALL_LEVELS
      if(nodetype(l).eq.1) then
#endif /* ADVANCE_ALL_LEVELS */


        dx = bsize(1,l)/(real(nxb/2)*2)

        rho => unk(1,:,:,:,l)
        vx => unk(2,:,:,:,l)
        vy => unk(3,:,:,:,l)
        vz => unk(4,:,:,:,l)

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! users timestep calaculation

        speed2(:,:,:) = (vx(:,:,:)*vx(:,:,:)+
     .       vy(:,:,:)*vy(:,:,:)+
     .       vz(:,:,:)*vz(:,:,:))/
     .       (rho(:,:,:)*rho(:,:,:)+1.e-10)


        maxspeed=0.
        do k=1+nguard*k3d,nzb+nguard*k3d
        do j=1+nguard*k2d,nyb+nguard*k2d
        do i=1+nguard,nxb+nguard
          maxspeed=max(maxspeed,speed2(i,j,k))
        enddo
        enddo
        enddo


        dtl = courant*dx/sqrt(maxspeed+1.e-10)

! end of users timestep calculation
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


        dtlevel(lrefine(l)) = min(dtlevel(lrefine(l)),dtl)

#ifndef ADVANCE_ALL_LEVELS
      endif
#endif /* ADVANCE_ALL_LEVELS */

      enddo
      endif
      call shmem_barrier_all()



!------------------------------------------


! find smallest timesteps for each refinement level  across all processors
      do i=1,maxlevels
        dtl0 = dtlevel(i)
        call comm_real_min_to_all(dtlevel(i),dtl0)
      enddo

      call shmem_barrier_all()

! ensure that the timestep does not increase as refinement level increases.
      do i=2,maxlevels
        dtlevel(i) = min(dtlevel(i),dtlevel(i-1))
      enddo

! ensure that each timestep is either equal to or a factor 2 larger
! than the timestep at the next higher refinement level.
      dtmin = dtlevel(maxlevels)
      dtmaxl = large_integer*dtmin
      do i=1,maxlevels-1
        dtlevel(i) = min(dtlevel(i),dtmaxl)
      enddo

      do i = maxlevels-1,1,-1
        ratio  = dtlevel(i)/dtlevel(i+1)
        iratio = max((int(ratio)/2)*2,1)
        iratio = min(iratio,2)
        dtlevel(i) = real(iratio)*dtlevel(i+1)
      enddo

      dtmaxl = 0.
      if(lnblocks.gt.0) then
      do l=1,lnblocks
      if(nodetype(l).eq.1) then
        dtmaxl = max(dtmaxl,dtlevel(lrefine(l)))
      endif
      enddo
      endif
      call shmem_barrier_all()

! find largest timestep for any leaf node across all processors
      dtl0 = dtmaxl
      call comm_real_max_to_all(dtmaxl,dtl0)
      call shmem_barrier_all()

      dtmax = dtmaxl


#ifdef VAR_DT
      dt = dtmax
#else
      dt = dtmin
      dtmax = dtmin
#endif

      if(mype.eq.0) write(*,*) 'proc ',mype,' dt ',dt
      call shmem_barrier_all()

      return
      end subroutine amr_timestep
